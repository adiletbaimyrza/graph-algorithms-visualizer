const pseudocodes = {
  bfs: [
    { indent: 0, content: 'function bfs(start, graph) {' },
    { indent: 10, content: 'const queue = [start]' },
    { indent: 10, content: 'const visited = new Set()' },
    { indent: 10, content: 'while (queue.length) {' },
    { indent: 20, content: 'const vertex = queue.shift()' },
    { indent: 20, content: 'if (!visited.has(vertex)) {' },
    { indent: 30, content: 'visited.add(vertex)' },
    { indent: 30, content: 'for (const neighbor of graph[vertex]) {' },
    { indent: 40, content: 'if (!visited.has(neighbor)) {' },
    { indent: 50, content: 'queue.push(neighbor)' },
    { indent: 40, content: '}' },
    { indent: 30, content: '}' },
    { indent: 20, content: '}' },
    { indent: 10, content: '}' },
    { indent: 0, content: '}' },
  ],
  dfs: [
    { indent: 0, content: 'function dfs(graph, start) {' },
    { indent: 10, content: 'const stack = [start]' },
    { indent: 10, content: 'const visited = new Set()' },
    { indent: 10, content: 'while (stack.length) {' },
    { indent: 20, content: 'const vertex = stack.pop()' },
    { indent: 20, content: 'if (!visited.has(vertex)) {' },
    { indent: 30, content: 'visited.add(vertex)' },
    { indent: 30, content: 'for (const neighbor of graph[vertex]) {' },
    { indent: 40, content: 'if (!visited.has(neighbor)) {' },
    { indent: 50, content: 'stack.push(neighbor)' },
    { indent: 40, content: '}' },
    { indent: 30, content: '}' },
    { indent: 20, content: '}' },
    { indent: 10, content: '}' },
    { indent: 0, content: '}' },
  ],
  prim: [
    { indent: 0, content: 'function prim(start, graph, weights): {' },
    { indent: 10, content: 'const minHeap = new MinHeap()' },
    { indent: 10, content: 'const visited = new Set()' },
    { indent: 10, content: 'visited.add(start)' },
    { indent: 10, content: 'for (const neighbor of graph[start]) {' },
    {
      indent: 20,
      content: 'minHeap.insert([start, neighbor, weights[start][neighbor])',
    },
    { indent: 10, content: '}' },
    { indent: 10, content: 'while (minHeap.length) {' },
    { indent: 20, content: 'const [from, to, weight] = minHeap.extractMin()' },
    { indent: 20, content: 'if (!visited.has(to)) {' },
    { indent: 30, content: 'visited.add(to)' },
    { indent: 30, content: 'for (const neighbor of graph[to]) {' },
    { indent: 40, content: 'if (!visited.has(neighbor) {' },
    {
      indent: 50,
      content: 'minHeap.insert([to, neighbor, weights[to][neighbor])',
    },
    { indent: 40, content: '}' },
    { indent: 30, content: '}' },
    { indent: 20, content: '}' },
    { indent: 10, content: '}' },
    { indent: 0, content: '}' },
  ],
  kruskal: [
    { indent: 0, content: 'function kruskal(vertices, edges): {' },
    { indent: 10, content: 'const dijsointSet = new DisjointSet()' },
    { indent: 10, content: 'const mst = new Array()' },
    { indent: 10, content: 'edges.sort()' },
    { indent: 10, content: 'for (const edge of edges) {' },
    {
      indent: 20,
      content: 'const { vx1, vx2, weight } = edge',
    },
    { indent: 20, content: 'if (!disjointSet.isConnected(vx1, vx2)) {' },
    { indent: 30, content: 'mst.push(edge)' },
    { indent: 30, content: 'disjointSet.union(vx1, vx2)' },
    { indent: 20, content: '}' },
    { indent: 10, content: '}' },
    { indent: 0, content: '}' },
  ],
  dijkstra: [
    { indent: 0, content: 'function dijkstra(start, vertices, graph, weights) {' },
    { indent: 10, content: 'const distances = new Map()' },
    { indent: 10, content: 'const previous = new Map()' },
    { indent: 10, content: 'const visited = new Set()' },
    { indent: 10, content: 'const minHeap = new MinHeap()' },
    { indent: 10, content: 'for (const vertex of vertices) {' },
    { indent: 20, content: 'if (start === vertex) {' },
    { indent: 30, content: 'distances.set(vertex, 0)' },
    { indent: 30, content: 'minHeap.insert(vertex)' },

    { indent: 20, content: 'else {' },
    { indent: 30, content: 'distances.set(vertex, Infinity)' },
    { indent: 20, content: '}' },
    { indent: 10, content: '}' },
    { indent: 10, content: 'while (minHeap.size() > 0) {' },
    { indent: 20, content: 'const curr = minHeap.extractMin()' },
    { indent: 40, content: 'visited.add(vertex)' },
    { indent: 40, content: 'for (const neighbor of graph[curr]) {' },
    { indent: 30, content: 'if (!visited.has(neighbor)) {' },

    { indent: 40, content: 'const newDist = distances.get(curr) + weights[curr][neighbor]' },
    { indent: 40, content: 'if (newDist < distances.get(neighbor)) {' },
    { indent: 50, content: 'distances.set(neighbor, newDist)' },
    { indent: 50, content: 'previous.set(neighbor, curr)' },

    { indent: 50, content: 'minHeap.insert(currVertex)' },
    { indent: 40, content: '}' },
    { indent: 30, content: '}' },
    { indent: 20, content: '}' },
    { indent: 10, content: '}' },
    { indent: 0, content: '}' },
  ],
}

export default pseudocodes
